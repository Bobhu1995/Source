```
雷神之锤学习笔记
```

#### Overview

* 《雷神之锤III竞技场》机器人的要求在第2节中列出。为FPS游戏创造一个机器人是一项广泛的任务，需要来自人工智能领域许多不同领域的专业知识。一些更常用的方法和技术将在第3部分松散地描述。第4部分将回顾之前有关FPS游戏和这些游戏中的人工智能的相关工作。第5节描述了雷神之锤III竞技场机器人的结构。第6至17节描述了用于机器人AI的子系统。这些部分的顺序是基于机器人是如何从头开始构建的。第18节提供了关于bot实现的一些细节，并显示了bot所使用的子系统的一些测试结果。第19节总结了在开发雷神之锤III竞技场机器人期间出现的发现。本节还提供了一些未来的改进方向和新机器人的开发。

#### **6 区域感知系统(Area Awareness System)**

1. AAS

2. Creating areas ：凸形导航具有最小复杂度的特性

   1. 碰撞检查(*Collision detection*)：uses bounding boxes for collision detection，使用`AABB`包围盒进行碰撞检测。
   2. 创建地图(Creating areas)：`Binary Space Partitioning (BSP) `是一个二叉树，将整个空间递归的分为前后两个半区，存储到每个半区存到树的节点之中。

   ![BSP](https://upload.wikimedia.org/wikipedia/commons/8/81/Binary_space_partition.png)

   	3. 构造实体几何(Constructive Solid Geometry)：某些情况重叠部分的brushes可以删除
    	4. 多种包围盒(More bounding boxes)：多个不同大小的边界框可以编译到同一个`BSP`树，当`BSP`树的叶子节点表示的凸子空间不包含展开的实体画刷的时候，所有的边界框都可以在哪里移动。当叶节点表示的凸子空间包含一个或多个为某个边界框展开的实体笔刷时，改边界框就不能在那里移动。
    	5. 内容卷(Contents of volumes)：水、熔岩和黏液用特殊的笔刷定义，可以展开并编译到`BSP`树中。
    	6. 固体点子树(Solid sub-trees )：
    	7. 门户化(Portalisation)：为了计算区域之间的可达性和路线，`BSP`树不能轻易用于计算区域之间的关系。以面为边界的区域表示会更适合。通过门户化`BSP`树来创建这样的表示。
    	8. 地图外(Outside maps)：地图是由画笔围起来的空间,玩家没法走出封闭的空间。通过前面的门户，可以找到所在位置的凸包，通过凸包的入口，可以找到其他所有的凸壳或封闭地图空间内的区域。标记这些凸包，其他的未被标记的凸包都可以被删除。
    	9. 细分引力(Gravitational subdivision)：区域之间可能存在缝隙，如果玩家掉到缝隙之中，则无法在该区域中任何两个可达点之间的直线上移动。如果存在这样的缝隙，这个区域会被分割成多个区域，它被一个穿过缝隙边缘的垂直平面分开。这些分裂的平面称为重力面。
    	10. 合并区域(Merging areas)：将两个凸包且不含缝隙的相邻区域，合并为一个`BSP`树节点。这种会导致`BSP`树的多个分支指向同一个区域。
    	11. 融合(Melting things together)：用于`AAS`的数据是所有区域的边界框表示和`BSP`树作为一个快速和常用区域的集合。区域的所有边界表示将共享数据。这些区域将共享面、面的边和顶点。这将允许更容易地找到共享的面，边和相邻区域之间的顶点。

 3. 环境提取( Environment sampling)：`BSP`可以轻松的原始三维数据中提取信息。

     1. 找到玩家所在区域(Finding the area a player is in)：`BSP`节点上的平面被存储为一个带有距离的法向量，这使得确定一个点位于平面的那边相当容易。
     2. `BSP`递归细分(Recursive subdivision by the BSP tree)：如果节点上的平面分割了机器人轨迹，则继续处理两个子节点，优先处理包含轨迹的子节点。在每个子节点上，只处理位于本节点上的轨迹段。如果轨迹还被平面分割，则重复此步骤。直到所有的`AAS`区域和轨迹所经过的实叶节点都被找到为止。
     3. 找到轨迹经过的区域(Finding the areas a trace goes through)：轨迹被`BSP`树切割成一个或多个经过特定区域的轨迹段，这些区域可以列出并用于很多事情。
     4. 包围盒所在的区域(Areas a bounding box is in)：从`BSP`根节点开始，计算边界框位于存储在该节点上平面的哪一侧。如果平面分裂了边界框，则在每个子节点上，再次计算存储在子节点中的平面的哪一侧，边界框位于，并相应地继续使用它的一个或两个子节点。 这个过程一直继续，直到找到边界框所在的 AAS 的所有区域。
     
4. 可达性(Reachability)

     1. 直线游泳(Swimming in a straight line)：游泳可达性在`AAS`数据中是最容易找到，在充满水或其他液体的区域中，玩家可以看到通向其他同样充满液体区的孔。创建一个游泳可达性，从该区域到通过发现的其他区域。
     2. 直线行走(Walking in a straight line)：大多数步行通道也很容易找到，通过看到相邻的区域，当玩家在两个区域中行走，并且两个区域中的楼层平面在边缘相遇时，便可以创造“行走”可达性。当玩家在两个区域之间需要蹲伏的时候，便会创造出“蹲伏”可达性。
     3. 蹲扶行进(Crouching in a straight line)：
     4. 跳上障碍物(Jumping onto a barrier)：两个存在高度差的平面，如果高度差小于玩家可以跳跃的高度，则可以创建一个跳跃可达性，从较低平面，跳跃到较高平面。
     5. 穿过窗台(Walking of a ledge)：从高的平面走向低的平面，此时高度差超过了行走可达性的高度差，则这种可达性不能返回。
     6. 跳出水面(Jumping out of the water)：从区域A1到A2没有创建上述可达性，则测试“水跃”可达性，当水面到A2平台的高度差小于跳跃高度时，从水面跳到地板上。A1区域充满水，A2区域没有水或者水比较浅。
     7. 跳跃(Jumping)：在两个区域的地面上寻找两个最近的点，其中一个点在A1区域的地面边缘，另一个点在A2区域的边缘，如果有一个距离最近的点的范围，适用范围内的距离，可以找到一个或多个缺口，通过预测缺口的跳跃轨迹可以预测玩家是否会撞到障碍物，如果没有障碍物则可以创建跳跃可达性，使得玩家可以按照缺口的跳跃轨迹跳到A2区域。如果A1和A2区域地面边缘的距离很近，或者A2区域比A1区域低一些，甚至可以通过奔跑到达A2区域，这样创建一个“walk of ledge”可达性即可。
     8. 远程传送(Teleporting)：存在传送笔刷，触发时直接传送到指定区域。
     9. 使用电梯( Using an elevator)：玩家站上电梯时，电梯会自动上升，电梯可达性只产生于电梯底部位置附近的区域或者电梯顶部位置的附近区域。
     10. 使用跳台(Using a jump pad)：跳跃平台也带有触发刷，玩家触碰时会以一定的速度推向一个特定的方向。跳跃垫的可达性指向玩家最终进入的区域，通过预测玩家从起跳板到落地位置的移动，可以计算出可达区域。加速点的原理和跳跃垫的原理完全一致。
     11. 使用浮动平台(Using a bobbing platform)：上下浮动平台是一个不断上下或者水平来回移动的实体。平台移动的位置是可以预测的，可以在某一时刻的四周寻找玩家可以的移动到的平台或从平台移动到附近区域。在两个位置的所有区域组合之间，可达性被创建为向上、向下和来回。
     12. 火箭跳(Rocket jumping)：玩家向地面发送火箭，并且同时跳跃。玩家会受到伤害，但不一定会被杀死，火箭爆炸会推动玩家向上。结合跳跃，玩家可以调到非常高的地方。运动过程中，玩家没有被障碍物阻挡，“火箭跳跃”可达性就产生了。
     13. 计算的复杂度(Complexity of calculations)：针对每个区域来说，复杂度是O(n2)。但是很多情况下，通过一个区域表面向其他区域蔓延可以大大加快计算速度。但是对于某些可达性不能这样做，比如跳跃可达性。但是跳跃可达性受限于跳跃的高度和距离，使得很多区域不需要考虑。

5. 路径选择(Routing)

     1. 实时计算 VS 预处理：由于地图不会改变，大多是情况下使用的是预先计算的表格。少数情况会因为某些微小但重要的变化，路线改变。这时会使用一个实时计算，计算的数据会被缓存起来。

     2. 传统的算法(Conventional algorithms)：雷神之锤地图比较大，Dijkstra算法和A*在大地图的场景开销太大。

     3. 多级缓存(Multi-level algorithm that calculates cache)：采用多级路由算法计算的精度和传统路由算法相同，优势在于，通常只需要较少的计算时间和存储空间。路由算法总是计算并缓存特定目标区域的路由数据。还需要考虑到目的地和起始地都在不断变化的情况。

     4. 路由缓存和集群(Routing cache and Clusters)：多级路由算法在两个层级计算路由缓存。在地图中，创建一个或多个区域集群，这些集群通集群门户连接，集群门户本身也是区域的集群。对于每个目标区域，门户缓存存储了每个门户区域带目标门户区域的通行事件，这个目标区域可以使地图上的任何区域。对于区域集群中的每个木变区域，区域缓存存储急群众每个区域朝向目标区域的通行时间，这里的目标区域必须是同一集群中的一个区域，包括与集群接触的集群门户。一般来说，并不是所有的路由缓存都会被计算。路由缓存将只计算和存储机器人已经拥有或仍然拥有的目标区域。存储所有可能的路由缓存的最大内存需求由下面的等式给出:

          ​		![eq.6.5.1](https://github.com/Bobhu1995/Source/blob/master/Quake3/Eq.6.5.1.png?raw=true)

     5. 计算路由缓存(Calculating routing caches)：广度优先算法从目标区域开始，利用反向可达性连接向其他其他区域，该算法仅在集群内部区域作用。算法回大量进入集群门户，

     6. 使用路由缓存(Using routing caches)：
     
     7. 最优的集群(Optimal clusters)：每个集群内区域数相同，切集群门户数量最小
     
6. 实体(entities)

     1. 

     



#### 7 基本操作(Basic Actions)

1. 人机输入(Human and Bot Input Interface)：人类通常使用键盘和鼠标来控制角色，为机器人提供一系列基础操作的接口，这些接口和鼠标键盘操作有着类似的输入输出，机器人将作出的决定转化为一系列的基础动作。有一些限制情况需要考虑，比如人类移动鼠标的速度理论上是没有限制的，但实际中，受限于人类物理限制，不太可能无限快。但是基础行为中并不会限制鼠标移动速度，这应该由AI逻辑中做出限制，使得更像人类。
2. 行为列表(Actions)
   1. Attack：发射当前持有的武器
   2. Use：使用当前持有的物品
   3. Respawn：重生
   4. Jump：跳跃
   5. Crouch：蹲下
   6. Move Up：向上游泳
   7. Move Down：向下游泳
   8. Move Forward：向前行进
   9. Move Back：向后移动
   10. Move Left：向左移动
   11. Move Right：向右移动
   12. Walk：走
   13. Talk：聊天框出现在机器人头上，不能移动
   14. Gesture：手势动画
   15. Move：接收两个参数，表示移动方向和速度
   16. View：设置机器人视角
   17. Select Weapon：设置机器人武器
   18. Command：游戏控制台输入命令
   19. Say：向所有玩家发送消息
   20. Say Team：向团队玩家发送消息



#### 8 机器人特征(Bot Characters)

1. 特征(Characters)：机器人有不同的特征集，带给玩家不同的挑战。每个风格的机器人都有一个集中的特征集，这些特征存储在分层结构中的第二次字符串模块中。每个字符可以改变的特征越多，字符就越通用，当更多变量出现时，不同的机器人角色也会变得难以预测。然而，简单的将许多特征添加到集合中不起作用，比如面对炮弹攻击时，跳跃和蹲下的反应是不能同时触发的。这些特征表名跳跃和蹲下的倾向。当选择一组特征的时候，应该记住玩家的感知是最重要的，玩家对机器人如何玩游戏的看法比机器人如何玩游戏更重要。

   ![分层结构](https://github.com/Bobhu1995/Source/blob/master/Quake3/Figure5.1.png?raw=true)

2. 特征列表

   ![特征列表](https://github.com/Bobhu1995/Source/blob/master/Quake3/Characteristics.png?raw=true)

   * 大多数特征的值在[0,1]范围内。值越高，特征越真实。“武器权重”和“道具权重”是指模糊逻辑存储的位置，分别用于情境相关的武器偏好和道具目标选择。

3. 完美的机器人通常是无趣的，一个稍微比玩家厉害一些的机器人很适合拿来训练



#### 9 机器人决策和偏好(Bot Decisions & Preferences)

1. 模糊逻辑(Fuzzy Logic)：通过模糊逻辑来指定机器人要做多少事、拥有多少东西，使用多少东西。介绍了神经网络可以来达成这个目的，但是本文没有使用神经网络。

2. 表示(Representation)：机器人的模糊关系存储以树状结构存储，树的叶子节点存储模糊值，树中的节点链接到树的下一层的叶子或节点。每个节点选择一个标准，用于模糊关系的评价。存储在纯文本中，使用类似C的语法。

   ![fuzzy logic](https://github.com/Bobhu1995/Source/blob/master/Quake3/FuzzyLogic.png?raw=true)

   * 每个模糊关系(权重)都有一个名称，不同的模糊关系通过名称来识别。switch语句选择代表世界某一部分状态的标准或者变量，case关键字将准则的取值范围划分为几个块，case关键字之后的值处于对值范围进行划分。case关键字的数量决定了划分的数量。
   * 模糊关系的评价如下，在每个节点计算一个标准，根据该标准的值转到下一个节点或者叶子。当到达一个叶子时，返回模糊值。然而这并不是最佳的方式，用准则划分间的插值递归地评价模糊关系，得到一个连续的模糊值范围，此时能够平滑的概括上面描述的指定信息。
   * 模糊关系代码的优缺点
     * 优点：树形结构很容易理解，模糊关系也很容易从情况推导出来，可以快照某一时刻，结合准则划分间插值模糊关系的递归评价，该结构概括并包含了所有情况。
     * 缺点：在switch和case语句中使用类似树的结构，会使得结构变得相当大，表达一些复杂关系时难以阅读。

3. 首选项(Preferences)：机器人有物品权重来决定它最想要的物品，每个机器人都有自己独立的道具权重。

   ![Teleporter item](https://github.com/Bobhu1995/Source/blob/master/Quake3/Figure9.1.png?raw=true)

   * `INVENTORY_TELEPORTER`是一个变量，当玩家拥有一个个人传送器时为1，`INVENTORY_MEDKIT`是一个变量，当玩家拥有一个医疗包时设置为1。一个玩家在任何时间只能持有一个可持有的物品。只有当机器人没有传送器和医疗箱时，才会返回高于零的模糊权重。

     ![Lightning gun](https://github.com/Bobhu1995/Source/blob/master/Quake3/Figure9.2.png?raw=true)

     ![Lightning gun fuzzy weight](https://github.com/Bobhu1995/Source/blob/master/Quake3/Figure9.3.png?raw=true)

   * 机器人还拥有武器权重来决定战斗中使用那种武器，上述模糊关系显示了机器人在战斗中对使用闪电枪的偏好。`INVENTORY_LIGHTNING`是一个变量，当机器人拥有闪电枪时设置为1。`ENEMY_HORIZONTAL_DIST`是一个变量，代表着玩家离敌人的距离。`NVENTORY_LIGHTNINGAMMO`是一个变量，代表机器人拥有的闪电枪弹药数量。只有当机器人拥有闪电枪且敌人在射程内时才会使用闪电枪。闪电的射程是768个单位。基于机器人拥有的闪电枪弹药数量，机器人或多或少会选择使用这种武器。对于每一种武器，机器人都有这样一个模糊的关系。这些模糊关系都描述了机器人在战斗中使用某一种武器的意愿。机器人更喜欢权重最大的武器。在上面的例子中，模糊值不在[0,1]的范围内。例如，使用70或80之类的值。模糊值的取值范围对机器人的决策和/或偏好没有影响，只要所有的权重相对于彼此是平衡的。

4. 基因选择(Genetic Selection)：确保道具和武器偏好的所有模糊关系都处于平衡状态是一项困难且耗时的任务。遗传选择可以使模糊关系更容易优化和平衡。通过遗传选择，人们可以努力平衡模糊关系，以使某些属性和特征显现出来。通过特定数量的机器人进行对战，选定特征进行排名，机器人的排名越高，机器人被选择为父母的几率就越高。机器人的排名越低，机器人被选为孩子的机会就越高。父母双方的模糊逻辑是杂交的。这是相当容易的，因为所有的机器人都从相同的模糊逻辑开始，因此树状结构都是相同的。在双亲模糊关系的模糊值之间取平均值可以进行杂交。杂交模糊关系取代了从孩子开始的模糊关系。这孩子现在有了模糊的新关系。这个过程的最后一步是改变孩子的模糊关系。用随机值稍微改变模糊关系中的值是一种选择。当孩子的模糊关系发生变异时，所有的机器人都会再次对打，整个过程继续进行。经过多次重复这一过程，机器人之间的模糊关系会根据排名倾向于具有特定的属性和特征，用于遗传选择。

​	

#### 10 机器人聊天(Bot Chats)

1. 通过文字沟通(Communication with text)：在团队游戏模式中，需要解析玩家说的话，做出回复或者自己主动触发一些发言。机器人输出的所有聊天消息都是预先构造的。通过使用随机或可变字符串作为消息的一部分，可以产生一些变化。对其他玩家聊天信息的解释相对简单。这些句子没有分解成动词、名词、形容词等。这种解释是基于聊天信息中的关键词。聊天消息也可以与已知的模板进行比较，以赋予消息意义。复杂的解析和分解通常不适用于像《雷神之锤3:竞技场》这样的快节奏游戏。通常没有足够的时间来分析这种复杂的句子。解析也经常失败，因为人们必须快速输入聊天消息，这导致许多错误和拼写错误的单词。在聊天信息中使用俚语也并不少见。

2. 解读句子(Interpreting text sentences)

   1. 同义词(Synonyms)：在进行进一步处理之前，同义词用于统一来自其他聊天消息。它们还用于在机器人构造聊天消息时添加变化。机器人使用上下文相关的同义词。每个上下文都有一个特殊的标志。同义词存储方式如下：

      ```
      context flag 
      { 
         [("word", X), ("a synonym of word", Y), ...] 
         ... 
      } 
      
      
      # A few examples
      CONTEXT_NEARBYITEM 
      { 
         [("Heavy Armor", 0), ("red armor", 0), ("Heavy Armour", 0), ("red armour", 0), ("ra", 0)] 
      } 
       
      CONTEXT_NORMAL 
      { 
         [("do not", 1), ("don't", 1), ("dont", 0)] 
         [("checkpoint", 1), ("check-point", 1), ("cp", 0)] 
      } 
      ```

      * X和Y的取值范围为[0-1]。这些值是在bot输出的聊天消息中使用同义词的机会。零的概率意味着机器人永远不会使用同义词。

   2. 匹配模板(Match templates)：机器人尝试用匹配模板来解析它收到的消息，匹配模板的存储方式如下：

      ```
      template = (id, type flags); 
      ```

      * ",0," 0表示变量下边，支持0-7，"|"类似于或操作

      * id用于标识消息。类型标志指定消息的某些属性。机器人使用这个id和标记来为消息赋予意义。

      * 机器人使用上下文相关的匹配模板。每个上下文都有一个上下文标志，多个匹配模板可以被组合到一个上下文中。

        ```
        context flag 
        { 
           ... 
        } 
         
        An example: 
         
        MTCONTEXT_INITIALTEAMCHAT 
        { 
           "(", NETNAME, "): ", ADDRESSEE, " defend ", KEYAREA,  “ for “, TIME = (MSG_DEFEND, 0); 
           ... 
        } 
        ```

        * `NETNAME`、`addressee`、`KEYAREA`、`TIME`和`MSG_DEFEND`是数字宏。机器人按照匹配模板的存储顺序使用它们。使用找到的第一个匹配项。

   3. 聊天(Initiating chats and Eliza chats)：当环境变化的时候，机器人有时会说一些话，例如，当被杀死时，机器人可以对敌人说“漂亮的一击”。该机器人还可以回复其他玩家说的话。例如，当有人对机器人说"你很好"机器人会回答"不，我没那么好"

      1. 初始化聊天(Initial chats)：每个机器人都有自己的一套初始化聊天线，在机器人特征中，有一个存储机器人初始化聊天线位置的引用。机器人初始化聊天记录存储如下：

         ```
         chat 
         { 
            type "type name" 
            { 
               "initial chat message"; 
               "another initial chat message"; 
               ... 
            } 
            type "type name" 
            { 
            } 
            ... 
         } 
         ```

         * 机器人可以根据类型名称选择消息。为特定类型列出的其中一条消息是随机选择的。

      2. 回复聊天(Reply chats)：机器人使用“回复聊天”来回复来自其他玩家的聊天信息，这些回复聊天的工作非常类似于Eliza聊天程序。所有机器人都使用相同的回复聊天，因为回复聊天的数量趋于增长。为每个机器人角色创建不同的回复聊天会耗费大量工作，也会占用大量内存。每个回复聊天都有键、优先级和多条回复聊天线：

         ```
         [key1, key2, ...] = priority 
         { 
            "reply chat message"; 
            "another reply chat message"; 
            ... 
         } 
          
         Possible keys: 
          
         name  	key is true when the name of the bot is found in the chat message 
         female  key is true when the bot is female 
         male  	key is true when the bot is male 
         It  	key is true when the bot is not male nor female 
         <"",""> key is true when the bot has one of these names, any number of names can be 
         		listed between the < and > 
         ""  	key is true when the string between the quotes is found in the message to reply to 
         ( )  	key is true when the chat message to reply to matches the template between the ( ) 
                 The match templates work in exactly the same way as the match templates 
                 described above. The matched variables can be used in the reply chat messages. 
                 For example: 
          
                 [("I'm not ", 0)] = 4 
                 { 
                    "yes you are ", 0; 
                 } 
         ```

         * 优先级是相对于其他应答聊天的优先级的值。机器人会对密钥进行评估，以确定回复聊天是否可以用于回复来自另一个玩家的某个聊天消息。一个键前面可以加一个&，这意味着该键必须为真。当一个键前加一个!密钥必须是假的。当所有带&前缀的键都为真，并且所有带前缀的键都为真时!不为真，且至少有一个前缀为真的键，则机器人可以使用回复聊天。当多条回复聊天可以同时回复一条消息时，选择优先级最高的一条。

           ```
           Reply chat examples: 
            
           ["hate you", !"not"] = 7 
           { 
              "why do you hate me"; 
              "there's no reason for you to hate me"; 
           } 
           
           # Only female bots can use the reply chat. 
           ["love you", !"not", &female] = 6 
           { 
              "am I the only woman you love?"; 
              "I love you to"; 
           }
           
           # Only the bots Grunt and Stripe can use the reply chat. 
           ["camper", !"not", &<"Grunt", "Stripe">] = 6 
           { 
              "I love camping"; 
              "I'm the king of all camp grounds"; 
              "camping with the rocket launcher is what Graeme told me to do"; 
              "so?.. you got a problem with campers?"; 
           } 
           
           ```

      3. 错误的聊天回复(Bad reply chats)：

         ```
         [&"looser", !"not", &female] = 6 
         { 
            "I'm not a looser"; 
         } 
         # 所有键都有前缀，没有机器人会使用这种回复，至少得有一个没有前缀的键必须为正
         
         [("I hate ", 0), "hate you"] = 7 
         { 
            "are you sure you hate ", 0; 
         } 
         # 变量0不一定有效
         
         [("get lost"), &name] = 7 
         { 
            "I never get lost"; 
         } 
         # 上面的回复聊天永远不会被使用，因为匹配模板中没有机器人的名字的空间
         
         [("do not say ", 0, " want to ", 1), !"not"] = 7 
         { 
            "but ", 0, " really want to ", 1; 
         }
         # 上面的回复聊天永远不会使用，因为“not”是“don ' t say”的子字符串。
         
         ["allowed"] = 7 
         { 
            "everything is allowed."; 
         } 
          
         ["not allowed"] = 5 
         { 
            "why isn't that allowed?"; 
         } 
         # 如果上述两个回复聊天都存在，那么机器人将永远不会回复“为什么不允许这样做”。
         ```

      4. 随机字符串(Random strings)：在初始和回复聊天消息中使用随机字符串来增加变化。一组随机字符串存储如下:

         ```
         rndname = {"first random string"; "second random string"; ...} 
         
         ferrari = {"F40"; "F50"} 
         BMW = {"BMW Z3"; "BMW Z8"} 
         cars = {ferrari; BMW; "F1 Mc Laren"} 
         ```

         * 可以在聊天消息中使用对随机字符串的多个引用。多个由分号分隔的随机字符串的引用也可以直接在后面使用。一组随机字符串也可能包含对其他随机字符串集的引用。当然，任何时候都必须避免递归。

      5. 聊天信息(Chat messages)：聊天信息中可以使用~防止单词被同义词替换，使用^+[0-7]使用不同的颜色。

3. 聊天推理(Chat reasoning)：下面的伪代码显示了如何使用聊天系统的不同部分：

   ```
   if environmental change then 
      if bot wants to chat then 
         choose initial chat 
         use random strings in chat message  
         replace synonyms in chat message to add variation  
         output chat message 
      endif 
   endif 
   ```

   * 有一些环境变化可能会触发机器人说话，例如，机器人可以在进入或退出游戏时发起聊天。当机器人已经在游戏中，一个新的地图开始时，机器人也可以决定聊天。当地图结束时，机器人也可以发起聊天，因为要么是机器人自己获胜，要么是其他人获胜。机器人可能会说“好游戏!”当机器人被敌人的炮弹击中时，它可能想要以聊天信息作为回应。当机器人输入一条信息的时候，它可以对它说些什么。例如，“嘿，我想说点什么。”当机器人死亡时，可以使用一系列不同的聊天信息。聊天信息是根据死因选择的。当机器人自杀时，它会说一些不同于敌人杀死机器人时所说的话。当机器人溺水、死于岩浆或坠亡时，会有不同的聊天信息。如果机器人被敌人杀死，它也可以选择说一些积极的话，或者它可能想要侮辱敌人。玩家可以根据敌人在与机器人的战斗中死亡的情况使用不同的聊天信息。机器人可能会侮辱敌人，比如说“你是个糟糕的失败者”，或者称赞敌人进行了公平的战斗。机器人也可以尝试进行对话，并决定在没有直接原因的情况下说出某些内容。在这种情况下，机器人可以对其中一个对手说一些侮辱或赞扬敌人的话。当某些事情发生时，机器人想要做出回应，或者机器人只是想说点什么，机器人会首先检查自己在游戏世界中的位置是否适合聊天。例如，在激烈的争吵中开始聊天是不明智的。

   * 下面的伪代码显示了机器人如何处理传入消息：

     ```
     if bot receives a message then 
        replace synonyms in the message 
        interpret message using match templates 
        if match is found then 
           perform action 
        else 
           if messages is a chat message from another player then 
              if bot wants to reply to this message then 
                 find a reply chat 
                 use random strings in chat message  
                 replace synonyms in chat message to add variation  
                 output chat message 
              endif 
           endif 
        endif 
     endif
     ```

     * 当找到匹配的模板时，机器人将使用提供的信息进行操作，或尝试完成团队成员所要求的内容。如果接收到的信息是来自其他人的聊天信息，而机器人无法理解其中的任何意义，那么机器人可以决定使用类似于Eliza的回复聊天来说些什么。机器人将遍历所有与聊天消息的密钥相匹配的回复聊天，并选择最适合回复的一个。



#### 11 机器人目标

1. 游戏目标(Ingame goals)：赢得比赛的胜利是最大的目标，在不同模式有不同的获胜目标，在死亡竞赛模式中，获胜是通过在游戏结束时拥有最高的碎片数(杀死对手的数量)。当玩家达到碎片限制或时间限制时，游戏结束。在常规的团队比赛中，累积破片数最高的队伍获胜。在夺旗游戏模式中，夺旗最多的队伍获胜。在团队游戏中，机器人将努力帮助自己的团队走向胜利。为了赢得游戏，机器人会在游戏过程中使用许多子目标。在死亡竞赛模式中，当然在团队游戏的战斗中，机器人会试图杀死敌人或直接对手。机器人必须瞄准并射击敌人。另一方面，机器人也会尝试在这样的战斗中生存。机器人将试图躲避敌人的炮弹和导弹。在战斗中，或者当周围没有敌人时，机器人将试图通过拾取道具、武器和升级道具来获得力量。游戏中还存在不同类型的子目标，即机器人能够以个人或团队的身份最终赢得游戏。首先，短期目标和长期目标之间的区别。短期目标是机器人在追求或优化长期目标的过程中实现的目标。当试图实现长期目标时，机器人使用几个短期目标来实现长期目标，或者因为它们在途中很容易实现。所有的短期目标和长期目标总是涉及环境中的一个位置或位置。
2. 短期目标(Short term goals)：在努力实现一个长期目标的同时，机器人会沿着这个路线实现几个短期目标。这些短期目标通常是附近的道具、武器或升级道具，机器人可以很容易地拿起这些道具，而不会偏离长期目标。当游向一个长期目标时，换气也被认为是一个短期目标。
3. 长期目标(Long term goals)：最常见的长期目标是道具、武器和升级道具。通过模糊逻辑来决定它想要的东西。当机器人结束战斗时，它可以实现几个长期目标。首先，机器人可以在直接战斗中杀死敌人。机器人将瞄准并射击敌人，并试图避开敌人的投射物和导弹。当机器人觉得自己不适合战斗时，它可能会决定撤退。在这种情况下，寻找远离敌人的道具是长期目标。当敌人逃跑时，机器人可以决定追赶敌人。在这种情况下，敌人是长期目标。当敌人消失在视线之外时，机器人会跑向敌人最后看到的位置，希望从那里看到敌人。机器人也可以决定在一个特定的位置停留一段时间，或者等待道具重生，或者因为它是一个机器人可以轻易消灭敌人的地方。这种行为通常被称为露营。在这种情况下，长期目标是保持在一个位置附近，给机器人一些优势。在团队游戏中，机器人可以有几个额外的长期目标。机器人是由团队领导命令去实现这些长期目标的。机器人能做的一件事就是帮助队友。机器人将走向队友并帮助他们对抗敌人。机器人还可以陪伴队友。机器人会跟随队友，帮助消灭途中遇到的敌人。机器人也可以被命令去保护环境中的关键区域。通常这个关键区域涉及到一个项目，例如CTF中的基本标志。机器人也可以在特定区域巡逻。在这种情况下，机器人通常被命令沿着某些物品进行巡逻。还有一些特殊的长期目标只适用于夺旗游戏。在《CTF》中，机器人可以尝试去偷敌人的旗帜。在这种情况下，敌人的旗帜将是长期目标。一旦机器人捡起敌人的旗帜，它就会冲回基地。当敌人窃取了机器人团队的旗帜时，机器人可以将归还旗帜作为长期目标。



#### 12  机器人寻路(Bot Navigation) 

1. 朝着目标移动(Moving towards a goal)：机器人总是在AAS区域内移动。机器人与目标在同一区域时，导航非常容易，机器人将直接按照直线向目标前进。如果机器人与目标不在同一个区域，可以使用路由系统来计算机器人为了达到目标需要到达的下一个区域。路由系统可以直接提供到达下一区域的可达性。如果有多条路径，将选择移动时间最短的路径进行移动。路由系统提供的可达性并没有直接使用，因为机器人可以决定避开某些区域。当机器人决定下一步要去哪个区域时，这些区域就可以被排除。当已知要去的下一个区域时，该区域的可达性也已知。机器人将利用这种可达性向目标移动。对于每种可达性类型，机器人都有专门的移动AI代码来沿着可达性移动。每个移动帧，机器人首先检查它是否站在电梯或浮动平台的顶部，如果是的，机器人将使用专门的AI可达性代码。如果路径意外的在某个移动对象身上结束，机器人将为它找到一个可达性，并为该可达性使用专门的代码。当机器人没有站在移动的物体上时，机器人会检查它是否在空中。对于每种可达性类型，都有专门的AI代码用于说明机器人何时在空中飞行，以及机器人何时站在地面或游泳。专门的代码用于机器人在空中飞行时，因为当机器人在空中飞行时，对运动的控制非常有限。当机器人不在空中时，机器人将继续使用从最后一个移动帧的可达性，除非机器人从那以后改变了区域。如果机器人在一个新的区域，机器人将在通往目标的路径上找到一个新的可到达区域。然后机器人继续新的可达性。机器人从一个区域移动到另一个区域，直到机器人到达目标所在的区域。
2. 朝着一个方向移动(Moving in a direction)：机器人在向特定方向移动时不使用可达性或路由系统。只使用环境采样功能。在游泳时，机器人可以毫无问题地朝着指定的方向移动，直到碰到墙壁或障碍物。当机器人行走时，还有更多不同的障碍需要处理。当机器人遇到障碍物时，它会验证自己是否能跳上障碍物。如果是这种情况，机器人将跳上障碍。当没有障碍物时，机器人会检查地板上的缝隙，以免落入其中。机器人会尝试跳过被发现的缝隙。在尝试跳跃之前，预计跳跃会找出机器人的最终位置。如果机器人将结束在熔岩，粘液或死亡坑机器人不会跳。当没有障碍物可以跳过，没有缝隙可以跳过时，机器人会尝试朝指定的方向移动。如果机器人撞到墙上，运动将失败。机器人将主要使用这种简单的导航AI代码在战斗中朝着特定的方向移动，例如避免敌人的投射物。



#### 13 机器人战斗

1. 获取敌人(Acquiring an enemy)：















【扩展参考】

1. https://deepmind.com/blog/article/capture-the-flag-science
2. 